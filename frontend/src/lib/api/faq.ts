import axios, { AxiosInstance } from 'axios';
import { useQuery, useMutation, useQueryClient, UseQueryOptions, UseMutationOptions } from '@tanstack/react-query';
import { endpoints } from './endpoints';
import { ApiResponse, PaginationParams } from './types';

// FAQ Types
export interface FAQ {
  id: string;
  question: string;
  answer: string;
  shortAnswer?: string;
  category: string;
  categoryId: string;
  tags: string[];
  
  // Content & Formatting
  answerHtml: string;
  answerMarkdown: string;
  relatedLinks: Array<{
    title: string;
    url: string;
    description?: string;
  }>;
  
  // SEO & Metadata
  slug: string;
  metaTitle?: string;
  metaDescription?: string;
  keywords: string[];
  
  // Organization
  order: number;
  featured: boolean;
  sticky: boolean;
  
  // Status & Visibility
  status: 'draft' | 'published' | 'archived' | 'under_review';
  isPublic: boolean;
  showOnHomepage: boolean;
  
  // Interaction Data
  views: number;
  likes: number;
  dislikes: number;
  helpfulVotes: number;
  notHelpfulVotes: number;
  helpfulnessRating: number;
  
  // User Engagement
  searchKeywords: string[];
  clickThroughRate: number;
  averageTimeRead: number;
  bounceRate: number;
  
  // Multilingual Support
  translations: Array<{
    language: string;
    question: string;
    answer: string;
    answerHtml: string;
    metaTitle?: string;
    metaDescription?: string;
  }>;
  
  // Related Content
  relatedFAQs: string[];
  relatedProducts: string[];
  relatedCategories: string[];
  
  // AI & Automation
  autoGenerated: boolean;
  aiSuggestions: string[];
  improvementSuggestions: string[];
  
  // Versioning
  version: number;
  lastReviewed: string;
  reviewedBy?: string;
  
  // Analytics
  analytics: FAQAnalytics;
  
  // Metadata
  createdBy: string;
  updatedBy?: string;
  createdAt: string;
  updatedAt: string;
  publishedAt?: string;
  metadata: Record<string, unknown>;
}

export interface FAQCategory {
  id: string;
  name: string;
  description: string;
  slug: string;
  icon?: string;
  color?: string;
  
  // Hierarchy
  parentId?: string;
  children: string[];
  level: number;
  path: string;
  
  // Content
  faqs: string[];
  faqCount: number;
  
  // Display
  order: number;
  featured: boolean;
  showInNavigation: boolean;
  
  // SEO
  metaTitle?: string;
  metaDescription?: string;
  keywords: string[];
  
  // Analytics
  views: number;
  searchCount: number;
  
  // Status
  isActive: boolean;
  
  createdAt: string;
  updatedAt: string;
}

export interface FAQAnalytics {
  faqId: string;
  period: string;
  
  // View Metrics
  totalViews: number;
  uniqueViews: number;
  viewsByDay: Array<{ date: string; views: number }>;
  
  // Engagement Metrics
  totalVotes: number;
  helpfulVotes: number;
  notHelpfulVotes: number;
  helpfulnessRate: number;
  
  // Search Metrics
  searchAppearances: number;
  searchClicks: number;
  searchCTR: number;
  topSearchKeywords: Array<{ keyword: string; count: number }>;
  
  // User Behavior
  averageReadTime: number;
  bounceRate: number;
  exitRate: number;
  
  // Conversion Metrics
  conversions: number;
  conversionRate: number;
  revenueImpact: number;
  
  // Geographic Data
  topCountries: Array<{ country: string; views: number; percentage: number }>;
  
  // Device Data
  deviceBreakdown: Array<{ device: string; views: number; percentage: number }>;
  
  // Referral Data
  topReferrers: Array<{ source: string; visits: number; percentage: number }>;
  
  updatedAt: string;
}

export interface FAQSuggestion {
  id: string;
  suggestedQuestion: string;
  suggestedAnswer?: string;
  source: 'user_query' | 'chat_log' | 'support_ticket' | 'ai_generated';
  frequency: number;
  
  // User Data
  suggestedBy?: string;
  userEmail?: string;
  
  // Processing
  status: 'pending' | 'approved' | 'rejected' | 'merged';
  processedBy?: string;
  processedAt?: string;
  notes?: string;
  
  // Related Content
  similarFAQs: string[];
  confidence: number;
  
  createdAt: string;
  updatedAt: string;
}

export interface FAQTemplate {
  id: string;
  name: string;
  description: string;
  category: string;
  
  // Template Structure
  questionTemplate: string;
  answerTemplate: string;
  defaultTags: string[];
  
  // Usage
  usageCount: number;
  isPublic: boolean;
  
  createdBy: string;
  createdAt: string;
  updatedAt: string;
}

export interface FAQSearchResult {
  faq: FAQ;
  relevanceScore: number;
  matchedFields: string[];
  highlightedSnippets: {
    question?: string;
    answer?: string;
  };
}

// Request/Response Types
export interface CreateFAQRequest {
  question: string;
  answer: string;
  categoryId: string;
  tags?: string[];
  status?: FAQ['status'];
  featured?: boolean;
  order?: number;
  metaTitle?: string;
  metaDescription?: string;
  keywords?: string[];
  relatedLinks?: Array<{
    title: string;
    url: string;
    description?: string;
  }>;
  translations?: Array<{
    language: string;
    question: string;
    answer: string;
  }>;
}

export interface UpdateFAQRequest extends Partial<CreateFAQRequest> {
  shortAnswer?: string;
  relatedFAQs?: string[];
  relatedProducts?: string[];
}

export interface CreateCategoryRequest {
  name: string;
  description: string;
  parentId?: string;
  icon?: string;
  color?: string;
  order?: number;
  featured?: boolean;
  metaTitle?: string;
  metaDescription?: string;
  keywords?: string[];
}

export interface UpdateCategoryRequest extends Partial<CreateCategoryRequest> {
  isActive?: boolean;
  showInNavigation?: boolean;
}

export interface FAQListParams extends PaginationParams {
  category?: string;
  status?: FAQ['status'];
  featured?: boolean;
  tags?: string[];
  search?: string;
  sortBy?: 'createdAt' | 'updatedAt' | 'order' | 'views' | 'helpfulness';
  sortOrder?: 'asc' | 'desc';
  language?: string;
}

export interface FAQSearchParams {
  query: string;
  category?: string;
  tags?: string[];
  limit?: number;
  includeAnswers?: boolean;
  fuzzySearch?: boolean;
}

export interface FAQStatsParams {
  startDate?: string;
  endDate?: string;
  category?: string;
  groupBy?: 'day' | 'week' | 'month';
}

export interface BulkFAQOperation {
  faqIds: string[];
  operation: 'publish' | 'archive' | 'delete' | 'update_category' | 'add_tags' | 'remove_tags';
  data?: Record<string, unknown>;
}

/**
 * FAQ API Service Class
 * Comprehensive FAQ and knowledge base management system
 */
class FAQApiService {
  private client: AxiosInstance;

  constructor(client: AxiosInstance) {
    this.client = client;
  }

  // Basic FAQ Operations
  async getFAQs(params?: FAQListParams): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.list, { params });
  }

  async getFAQ(id: string): Promise<ApiResponse<FAQ>> {
    return this.client.get(endpoints.faq.byId(id));
  }

  async getFAQBySlug(slug: string): Promise<ApiResponse<FAQ>> {
    return this.client.get(endpoints.faq.bySlug(slug));
  }

  async createFAQ(data: CreateFAQRequest): Promise<ApiResponse<FAQ>> {
    return this.client.post(endpoints.faq.create, data);
  }

  async updateFAQ(id: string, data: UpdateFAQRequest): Promise<ApiResponse<FAQ>> {
    return this.client.put(endpoints.faq.update(id), data);
  }

  async deleteFAQ(id: string): Promise<ApiResponse<void>> {
    return this.client.delete(endpoints.faq.delete(id));
  }

  async duplicateFAQ(id: string, data?: { question?: string; categoryId?: string }): Promise<ApiResponse<FAQ>> {
    return this.client.post(endpoints.faq.duplicate(id), data);
  }

  // FAQ Status Management
  async publishFAQ(id: string): Promise<ApiResponse<FAQ>> {
    return this.client.patch(endpoints.faq.publish(id));
  }

  async archiveFAQ(id: string): Promise<ApiResponse<FAQ>> {
    return this.client.patch(endpoints.faq.archive(id));
  }

  async setFeatured(id: string, featured: boolean, order?: number): Promise<ApiResponse<FAQ>> {
    return this.client.patch(endpoints.faq.featured, { faqId: id, featured, order });
  }

  async reorderFAQs(categoryId: string, faqOrders: Array<{ id: string; order: number }>): Promise<ApiResponse<{ updated: number }>> {
    return this.client.patch(endpoints.faq.reorder, { categoryId, faqOrders });
  }

  // FAQ Categories
  async getCategories(params?: PaginationParams): Promise<ApiResponse<FAQCategory[]>> {
    return this.client.get(endpoints.faq.categories.list, { params });
  }

  async getCategory(id: string): Promise<ApiResponse<FAQCategory>> {
    return this.client.get(endpoints.faq.categories.byId(id));
  }

  async getCategoryBySlug(slug: string): Promise<ApiResponse<FAQCategory>> {
    return this.client.get(endpoints.faq.categories.bySlug(slug));
  }

  async createCategory(data: CreateCategoryRequest): Promise<ApiResponse<FAQCategory>> {
    return this.client.post(endpoints.faq.categories.create, data);
  }

  async updateCategory(id: string, data: UpdateCategoryRequest): Promise<ApiResponse<FAQCategory>> {
    return this.client.put(endpoints.faq.categories.update(id), data);
  }

  async deleteCategory(id: string, options?: { moveToCategory?: string; deleteFAQs?: boolean }): Promise<ApiResponse<void>> {
    return this.client.delete(endpoints.faq.categories.delete(id), {
      data: options
    });
  }

  async getCategoryFAQs(categoryId: string, params?: FAQListParams): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.categories.faqs(categoryId), { params });
  }

  async getCategoryTree(): Promise<ApiResponse<FAQCategory[]>> {
    return this.client.get(endpoints.faq.categories.tree);
  }

  // Featured & Popular FAQs
  async getFeaturedFAQs(params?: Omit<FAQListParams, 'featured'>): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.featured, { params });
  }

  async getPopularFAQs(params?: { limit?: number; period?: 'day' | 'week' | 'month' | 'all' }): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.popular, { params });
  }

  async getRecentFAQs(params?: { limit?: number; category?: string }): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.recent, { params });
  }

  async getRelatedFAQs(id: string, limit?: number): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.related(id), { params: { limit } });
  }

  // Search & Filter
  async searchFAQs(params: FAQSearchParams): Promise<ApiResponse<FAQSearchResult[]>> {
    return this.client.get(endpoints.faq.search, { params });
  }

  async getSearchSuggestions(query: string, limit?: number): Promise<ApiResponse<string[]>> {
    return this.client.get(endpoints.faq.searchSuggestions, {
      params: { query, limit }
    });
  }

  async getAutoComplete(query: string, limit?: number): Promise<ApiResponse<Array<{
    text: string;
    type: 'question' | 'category' | 'tag';
    faqId?: string;
    categoryId?: string;
  }>>> {
    return this.client.get(endpoints.faq.autoComplete, {
      params: { query, limit }
    });
  }

  // FAQ Interaction
  async voteFAQ(id: string, helpful: boolean): Promise<ApiResponse<{ helpful: number; notHelpful: number }>> {
    return this.client.post(endpoints.faq.vote(id), { helpful });
  }

  async viewFAQ(id: string, metadata?: { userAgent?: string; referrer?: string }): Promise<ApiResponse<void>> {
    return this.client.post(endpoints.faq.view(id), metadata);
  }

  async reportFAQ(id: string, data: {
    reason: 'inaccurate' | 'outdated' | 'inappropriate' | 'spam' | 'other';
    description?: string;
    email?: string;
  }): Promise<ApiResponse<{ reported: boolean }>> {
    return this.client.post(endpoints.faq.report(id), data);
  }

  // FAQ Suggestions
  async getFAQSuggestions(params?: PaginationParams & { status?: FAQSuggestion['status'] }): Promise<ApiResponse<FAQSuggestion[]>> {
    return this.client.get(endpoints.faq.suggestions.list, { params });
  }

  async createFAQSuggestion(data: {
    suggestedQuestion: string;
    suggestedAnswer?: string;
    userEmail?: string;
    category?: string;
  }): Promise<ApiResponse<FAQSuggestion>> {
    return this.client.post(endpoints.faq.suggestions.create, data);
  }

  async processFAQSuggestion(id: string, data: {
    status: 'approved' | 'rejected' | 'merged';
    notes?: string;
    faqId?: string; // If merged with existing FAQ
  }): Promise<ApiResponse<FAQSuggestion>> {
    return this.client.patch(endpoints.faq.suggestions.process(id), data);
  }

  async deleteFAQSuggestion(id: string): Promise<ApiResponse<void>> {
    return this.client.delete(endpoints.faq.suggestions.delete(id));
  }

  // FAQ Templates
  async getFAQTemplates(params?: PaginationParams): Promise<ApiResponse<FAQTemplate[]>> {
    return this.client.get(endpoints.faq.templates.list, { params });
  }

  async getFAQTemplate(id: string): Promise<ApiResponse<FAQTemplate>> {
    return this.client.get(endpoints.faq.templates.byId(id));
  }

  async createFAQTemplate(data: {
    name: string;
    description: string;
    category: string;
    questionTemplate: string;
    answerTemplate: string;
    defaultTags?: string[];
    isPublic?: boolean;
  }): Promise<ApiResponse<FAQTemplate>> {
    return this.client.post(endpoints.faq.templates.create, data);
  }

  async updateFAQTemplate(id: string, data: Partial<{
    name: string;
    description: string;
    questionTemplate: string;
    answerTemplate: string;
    defaultTags: string[];
    isPublic: boolean;
  }>): Promise<ApiResponse<FAQTemplate>> {
    return this.client.put(endpoints.faq.templates.update(id), data);
  }

  async deleteFAQTemplate(id: string): Promise<ApiResponse<void>> {
    return this.client.delete(endpoints.faq.templates.delete(id));
  }

  async createFAQFromTemplate(templateId: string, data: {
    categoryId: string;
    customData?: Record<string, unknown>;
    overrides?: Partial<CreateFAQRequest>;
  }): Promise<ApiResponse<FAQ>> {
    return this.client.post(endpoints.faq.templates.createFAQ(templateId), data);
  }

  // Analytics & Statistics
  async getFAQAnalytics(id: string, params?: FAQStatsParams): Promise<ApiResponse<FAQAnalytics>> {
    return this.client.get(endpoints.faq.analytics(id), { params });
  }

  async getFAQStats(params?: FAQStatsParams): Promise<ApiResponse<{
    totalFAQs: number;
    publishedFAQs: number;
    totalViews: number;
    totalVotes: number;
    averageHelpfulness: number;
    topCategories: Array<{ category: string; faqCount: number; views: number }>;
    topFAQs: Array<{ id: string; question: string; views: number; helpfulness: number }>;
    viewsByDay: Array<{ date: string; views: number }>;
    searchStats: {
      totalSearches: number;
      uniqueQueries: number;
      avgResultsShown: number;
      topQueries: Array<{ query: string; count: number; results: number }>;
    };
  }>> {
    return this.client.get(endpoints.faq.stats, { params });
  }

  async getCategoryStats(categoryId: string, params?: FAQStatsParams): Promise<ApiResponse<{
    category: FAQCategory;
    faqCount: number;
    totalViews: number;
    totalVotes: number;
    averageHelpfulness: number;
    topFAQs: Array<{ id: string; question: string; views: number }>;
    viewTrends: Array<{ date: string; views: number }>;
  }>> {
    return this.client.get(endpoints.faq.categories.stats(categoryId), { params });
  }

  // Bulk Operations
  async bulkUpdateFAQs(operation: BulkFAQOperation): Promise<ApiResponse<{
    success: number;
    failed: number;
    errors: Array<{ faqId: string; error: string }>;
  }>> {
    return this.client.post(endpoints.faq.bulk.update, operation);
  }

  async bulkDeleteFAQs(faqIds: string[]): Promise<ApiResponse<{
    deleted: number;
    failed: number;
    errors: Array<{ faqId: string; error: string }>;
  }>> {
    return this.client.delete(endpoints.faq.bulk.delete, {
      data: { faqIds }
    });
  }

  // Import/Export
  async importFAQs(file: File, options?: {
    categoryId?: string;
    skipErrors?: boolean;
    updateExisting?: boolean;
    dryRun?: boolean;
  }): Promise<ApiResponse<{
    imported: number;
    updated: number;
    errors: Array<{ row: number; error: string }>;
    preview?: FAQ[];
  }>> {
    const formData = new FormData();
    formData.append('file', file);
    if (options) {
      Object.entries(options).forEach(([key, value]) => {
        formData.append(key, String(value));
      });
    }

    return this.client.post(endpoints.faq.import, formData, {
      headers: { 'Content-Type': 'multipart/form-data' }
    });
  }

  async exportFAQs(params?: {
    format?: 'csv' | 'xlsx' | 'json' | 'pdf';
    category?: string;
    status?: FAQ['status'];
    includeAnalytics?: boolean;
    includeTranslations?: boolean;
  }): Promise<ApiResponse<{ downloadUrl: string; filename: string }>> {
    return this.client.get(endpoints.faq.export, {
      params,
      responseType: 'blob'
    });
  }

  // AI & Automation
  async generateFAQFromContent(data: {
    content: string;
    contentType: 'article' | 'documentation' | 'conversation' | 'support_ticket';
    categoryId?: string;
    maxFAQs?: number;
  }): Promise<ApiResponse<Array<{
    question: string;
    answer: string;
    confidence: number;
    suggestedTags: string[];
  }>>> {
    return this.client.post(endpoints.faq.ai.generate, data);
  }

  async improveFAQAnswer(id: string, options?: {
    tone?: 'professional' | 'friendly' | 'technical' | 'casual';
    length?: 'shorter' | 'longer' | 'detailed';
    includeExamples?: boolean;
  }): Promise<ApiResponse<{
    improvedAnswer: string;
    suggestions: string[];
    changes: Array<{ type: string; description: string }>;
  }>> {
    return this.client.post(endpoints.faq.ai.improve(id), options);
  }

  async getSimilarFAQs(id: string, threshold?: number): Promise<ApiResponse<Array<{
    faq: FAQ;
    similarity: number;
    commonKeywords: string[];
  }>>> {
    return this.client.get(endpoints.faq.ai.similar(id), {
      params: { threshold }
    });
  }

  async translateFAQ(id: string, targetLanguages: string[]): Promise<ApiResponse<{
    translations: Array<{
      language: string;
      question: string;
      answer: string;
      confidence: number;
    }>;
  }>> {
    return this.client.post(endpoints.faq.ai.translate(id), { targetLanguages });
  }

  // Multilingual Support
  async getFAQTranslations(id: string): Promise<ApiResponse<Array<{
    language: string;
    question: string;
    answer: string;
    metaTitle?: string;
    metaDescription?: string;
    status: 'active' | 'needs_review' | 'outdated';
  }>>> {
    return this.client.get(endpoints.faq.translations(id));
  }

  async updateFAQTranslation(id: string, language: string, data: {
    question: string;
    answer: string;
    metaTitle?: string;
    metaDescription?: string;
  }): Promise<ApiResponse<FAQ>> {
    return this.client.put(endpoints.faq.updateTranslation(id, language), data);
  }

  async deleteFAQTranslation(id: string, language: string): Promise<ApiResponse<void>> {
    return this.client.delete(endpoints.faq.deleteTranslation(id, language));
  }

  // FAQ Review & Moderation
  async getFAQsForReview(params?: PaginationParams): Promise<ApiResponse<FAQ[]>> {
    return this.client.get(endpoints.faq.review.list, { params });
  }

  async reviewFAQ(id: string, data: {
    approved: boolean;
    notes?: string;
    changes?: Partial<UpdateFAQRequest>;
  }): Promise<ApiResponse<FAQ>> {
    return this.client.post(endpoints.faq.review.process(id), data);
  }

  async flagFAQForReview(id: string, reason?: string): Promise<ApiResponse<{ flagged: boolean }>> {
    return this.client.post(endpoints.faq.review.flag(id), { reason });
  }

  // Content Validation
  async validateFAQ(data: CreateFAQRequest): Promise<ApiResponse<{
    valid: boolean;
    errors: Array<{ field: string; message: string }>;
    warnings: Array<{ field: string; message: string }>;
    suggestions: string[];
    seoScore: number;
    readabilityScore: number;
  }>> {
    return this.client.post(endpoints.faq.validate, data);
  }

  async checkDuplicates(question: string, categoryId?: string): Promise<ApiResponse<Array<{
    faq: FAQ;
    similarity: number;
    matchType: 'exact' | 'similar' | 'partial';
  }>>> {
    return this.client.post(endpoints.faq.checkDuplicates, { question, categoryId });
  }
}

// Create service instance
const faqApi = new FAQApiService(axios);

// React Query Hooks

// Basic FAQ Hooks
export const useFAQs = (
  params?: FAQListParams,
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['faqs', params],
    queryFn: () => faqApi.getFAQs(params),
    ...options,
  });
};

export const useFAQ = (
  id: string,
  options?: UseQueryOptions<ApiResponse<FAQ>>
) => {
  return useQuery({
    queryKey: ['faq', id],
    queryFn: () => faqApi.getFAQ(id),
    enabled: !!id,
    ...options,
  });
};

export const useFAQBySlug = (
  slug: string,
  options?: UseQueryOptions<ApiResponse<FAQ>>
) => {
  return useQuery({
    queryKey: ['faq-by-slug', slug],
    queryFn: () => faqApi.getFAQBySlug(slug),
    enabled: !!slug,
    ...options,
  });
};

export const useCreateFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, CreateFAQRequest>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.createFAQ,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-stats'] });
      queryClient.invalidateQueries({ queryKey: ['categories'] });
    },
    ...options,
  });
};

export const useUpdateFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { id: string; data: UpdateFAQRequest }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.updateFAQ(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-analytics', id] });
    },
    ...options,
  });
};

export const useDeleteFAQ = (
  options?: UseMutationOptions<ApiResponse<void>, Error, string>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.deleteFAQ,
    onSuccess: (data, id) => {
      queryClient.removeQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-stats'] });
    },
    ...options,
  });
};

export const useDuplicateFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { id: string; data?: { question?: string; categoryId?: string } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.duplicateFAQ(id, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

// FAQ Status Hooks
export const usePublishFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, string>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.publishFAQ,
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

export const useArchiveFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, string>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.archiveFAQ,
    onSuccess: (data, id) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

export const useSetFeaturedFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { id: string; featured: boolean; order?: number }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, featured, order }) => faqApi.setFeatured(id, featured, order),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['featured-faqs'] });
    },
    ...options,
  });
};

export const useReorderFAQs = (
  options?: UseMutationOptions<ApiResponse<{ updated: number }>, Error, { categoryId: string; faqOrders: Array<{ id: string; order: number }> }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ categoryId, faqOrders }) => faqApi.reorderFAQs(categoryId, faqOrders),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

// Category Hooks
export const useFAQCategories = (
  params?: PaginationParams,
  options?: UseQueryOptions<ApiResponse<FAQCategory[]>>
) => {
  return useQuery({
    queryKey: ['faq-categories', params],
    queryFn: () => faqApi.getCategories(params),
    ...options,
  });
};

export const useFAQCategory = (
  id: string,
  options?: UseQueryOptions<ApiResponse<FAQCategory>>
) => {
  return useQuery({
    queryKey: ['faq-category', id],
    queryFn: () => faqApi.getCategory(id),
    enabled: !!id,
    ...options,
  });
};

export const useFAQCategoryBySlug = (
  slug: string,
  options?: UseQueryOptions<ApiResponse<FAQCategory>>
) => {
  return useQuery({
    queryKey: ['faq-category-by-slug', slug],
    queryFn: () => faqApi.getCategoryBySlug(slug),
    enabled: !!slug,
    ...options,
  });
};

export const useCreateFAQCategory = (
  options?: UseMutationOptions<ApiResponse<FAQCategory>, Error, CreateCategoryRequest>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.createCategory,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faq-categories'] });
      queryClient.invalidateQueries({ queryKey: ['category-tree'] });
    },
    ...options,
  });
};

export const useUpdateFAQCategory = (
  options?: UseMutationOptions<ApiResponse<FAQCategory>, Error, { id: string; data: UpdateCategoryRequest }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.updateCategory(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq-category', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-categories'] });
      queryClient.invalidateQueries({ queryKey: ['category-tree'] });
    },
    ...options,
  });
};

export const useDeleteFAQCategory = (
  options?: UseMutationOptions<ApiResponse<void>, Error, { id: string; options?: { moveToCategory?: string; deleteFAQs?: boolean } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, options }) => faqApi.deleteCategory(id, options),
    onSuccess: (data, { id }) => {
      queryClient.removeQueries({ queryKey: ['faq-category', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-categories'] });
      queryClient.invalidateQueries({ queryKey: ['category-tree'] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

export const useCategoryFAQs = (
  categoryId: string,
  params?: FAQListParams,
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['category-faqs', categoryId, params],
    queryFn: () => faqApi.getCategoryFAQs(categoryId, params),
    enabled: !!categoryId,
    ...options,
  });
};

export const useCategoryTree = (
  options?: UseQueryOptions<ApiResponse<FAQCategory[]>>
) => {
  return useQuery({
    queryKey: ['category-tree'],
    queryFn: () => faqApi.getCategoryTree(),
    ...options,
  });
};

// Featured & Popular Hooks
export const useFeaturedFAQs = (
  params?: Omit<FAQListParams, 'featured'>,
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['featured-faqs', params],
    queryFn: () => faqApi.getFeaturedFAQs(params),
    ...options,
  });
};

export const usePopularFAQs = (
  params?: { limit?: number; period?: 'day' | 'week' | 'month' | 'all' },
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['popular-faqs', params],
    queryFn: () => faqApi.getPopularFAQs(params),
    ...options,
  });
};

export const useRecentFAQs = (
  params?: { limit?: number; category?: string },
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['recent-faqs', params],
    queryFn: () => faqApi.getRecentFAQs(params),
    ...options,
  });
};

export const useRelatedFAQs = (
  id: string,
  limit?: number,
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['related-faqs', id, limit],
    queryFn: () => faqApi.getRelatedFAQs(id, limit),
    enabled: !!id,
    ...options,
  });
};

// Search Hooks
export const useSearchFAQs = (
  params: FAQSearchParams,
  options?: UseQueryOptions<ApiResponse<FAQSearchResult[]>>
) => {
  return useQuery({
    queryKey: ['search-faqs', params],
    queryFn: () => faqApi.searchFAQs(params),
    enabled: !!params.query && params.query.length >= 2,
    ...options,
  });
};

export const useSearchSuggestions = (
  query: string,
  limit?: number,
  options?: UseQueryOptions<ApiResponse<string[]>>
) => {
  return useQuery({
    queryKey: ['search-suggestions', query, limit],
    queryFn: () => faqApi.getSearchSuggestions(query, limit),
    enabled: !!query && query.length >= 2,
    ...options,
  });
};

export const useAutoCompleteFAQ = (
  query: string,
  limit?: number,
  options?: UseQueryOptions<ApiResponse<Array<{
    text: string;
    type: 'question' | 'category' | 'tag';
    faqId?: string;
    categoryId?: string;
  }>>>
) => {
  return useQuery({
    queryKey: ['autocomplete-faq', query, limit],
    queryFn: () => faqApi.getAutoComplete(query, limit),
    enabled: !!query && query.length >= 1,
    ...options,
  });
};

// Interaction Hooks
export const useVoteFAQ = (
  options?: UseMutationOptions<ApiResponse<{ helpful: number; notHelpful: number }>, Error, { id: string; helpful: boolean }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, helpful }) => faqApi.voteFAQ(id, helpful),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-analytics', id] });
    },
    ...options,
  });
};

export const useViewFAQ = (
  options?: UseMutationOptions<ApiResponse<void>, Error, { id: string; metadata?: { userAgent?: string; referrer?: string } }>
) => {
  return useMutation({
    mutationFn: ({ id, metadata }) => faqApi.viewFAQ(id, metadata),
    ...options,
  });
};

export const useReportFAQ = (
  options?: UseMutationOptions<ApiResponse<{ reported: boolean }>, Error, { id: string; data: {
    reason: 'inaccurate' | 'outdated' | 'inappropriate' | 'spam' | 'other';
    description?: string;
    email?: string;
  } }>
) => {
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.reportFAQ(id, data),
    ...options,
  });
};

// Suggestion Hooks
export const useFAQSuggestions = (
  params?: PaginationParams & { status?: FAQSuggestion['status'] },
  options?: UseQueryOptions<ApiResponse<FAQSuggestion[]>>
) => {
  return useQuery({
    queryKey: ['faq-suggestions', params],
    queryFn: () => faqApi.getFAQSuggestions(params),
    ...options,
  });
};

export const useCreateFAQSuggestion = (
  options?: UseMutationOptions<ApiResponse<FAQSuggestion>, Error, {
    suggestedQuestion: string;
    suggestedAnswer?: string;
    userEmail?: string;
    category?: string;
  }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.createFAQSuggestion,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faq-suggestions'] });
    },
    ...options,
  });
};

export const useProcessFAQSuggestion = (
  options?: UseMutationOptions<ApiResponse<FAQSuggestion>, Error, { id: string; data: {
    status: 'approved' | 'rejected' | 'merged';
    notes?: string;
    faqId?: string;
  } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.processFAQSuggestion(id, data),
    onSuccess: (response, { id }) => {
      console.log('FAQ suggestion processed:', response, 'for FAQ ID:', id);
      queryClient.invalidateQueries({ queryKey: ['faq-suggestions'] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

export const useDeleteFAQSuggestion = (
  options?: UseMutationOptions<ApiResponse<void>, Error, string>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.deleteFAQSuggestion,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faq-suggestions'] });
    },
    ...options,
  });
};

// Template Hooks
export const useFAQTemplates = (
  params?: PaginationParams,
  options?: UseQueryOptions<ApiResponse<FAQTemplate[]>>
) => {
  return useQuery({
    queryKey: ['faq-templates', params],
    queryFn: () => faqApi.getFAQTemplates(params),
    ...options,
  });
};

export const useFAQTemplate = (
  id: string,
  options?: UseQueryOptions<ApiResponse<FAQTemplate>>
) => {
  return useQuery({
    queryKey: ['faq-template', id],
    queryFn: () => faqApi.getFAQTemplate(id),
    enabled: !!id,
    ...options,
  });
};

export const useCreateFAQTemplate = (
  options?: UseMutationOptions<ApiResponse<FAQTemplate>, Error, {
    name: string;
    description: string;
    category: string;
    questionTemplate: string;
    answerTemplate: string;
    defaultTags?: string[];
    isPublic?: boolean;
  }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.createFAQTemplate,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faq-templates'] });
    },
    ...options,
  });
};

export const useUpdateFAQTemplate = (
  options?: UseMutationOptions<ApiResponse<FAQTemplate>, Error, { id: string; data: Partial<{
    name: string;
    description: string;
    questionTemplate: string;
    answerTemplate: string;
    defaultTags: string[];
    isPublic: boolean;
  }> }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.updateFAQTemplate(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq-template', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-templates'] });
    },
    ...options,
  });
};

export const useDeleteFAQTemplate = (
  options?: UseMutationOptions<ApiResponse<void>, Error, string>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.deleteFAQTemplate,
    onSuccess: (data, id) => {
      queryClient.removeQueries({ queryKey: ['faq-template', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-templates'] });
    },
    ...options,
  });
};

export const useCreateFAQFromTemplate = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { templateId: string; data: {
    categoryId: string;
    customData?: Record<string, unknown>;
    overrides?: Partial<CreateFAQRequest>;
  } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ templateId, data }) => faqApi.createFAQFromTemplate(templateId, data),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
    },
    ...options,
  });
};

// Analytics Hooks
export const useFAQAnalytics = (
  id: string,
  params?: FAQStatsParams,
  options?: UseQueryOptions<ApiResponse<FAQAnalytics>>
) => {
  return useQuery({
    queryKey: ['faq-analytics', id, params],
    queryFn: () => faqApi.getFAQAnalytics(id, params),
    enabled: !!id,
    ...options,
  });
};

export const useFAQStats = (
  params?: FAQStatsParams,
  options?: UseQueryOptions<ApiResponse<{
    totalFAQs: number;
    publishedFAQs: number;
    totalViews: number;
    totalVotes: number;
    averageHelpfulness: number;
    topCategories: Array<{ category: string; faqCount: number; views: number }>;
    topFAQs: Array<{ id: string; question: string; views: number; helpfulness: number }>;
    viewsByDay: Array<{ date: string; views: number }>;
    searchStats: {
      totalSearches: number;
      uniqueQueries: number;
      avgResultsShown: number;
      topQueries: Array<{ query: string; count: number; results: number }>;
    };
  }>>
) => {
  return useQuery({
    queryKey: ['faq-stats', params],
    queryFn: () => faqApi.getFAQStats(params),
    ...options,
  });
};

export const useCategoryStats = (
  categoryId: string,
  params?: FAQStatsParams,
  options?: UseQueryOptions<ApiResponse<{
    category: FAQCategory;
    faqCount: number;
    totalViews: number;
    totalVotes: number;
    averageHelpfulness: number;
    topFAQs: Array<{ id: string; question: string; views: number }>;
    viewTrends: Array<{ date: string; views: number }>;
  }>>
) => {
  return useQuery({
    queryKey: ['category-stats', categoryId, params],
    queryFn: () => faqApi.getCategoryStats(categoryId, params),
    enabled: !!categoryId,
    ...options,
  });
};

// Bulk Operations Hooks
export const useBulkUpdateFAQs = (
  options?: UseMutationOptions<ApiResponse<{
    success: number;
    failed: number;
    errors: Array<{ faqId: string; error: string }>;
  }>, Error, BulkFAQOperation>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.bulkUpdateFAQs,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-stats'] });
    },
    ...options,
  });
};

export const useBulkDeleteFAQs = (
  options?: UseMutationOptions<ApiResponse<{
    deleted: number;
    failed: number;
    errors: Array<{ faqId: string; error: string }>;
  }>, Error, string[]>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: faqApi.bulkDeleteFAQs,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-stats'] });
    },
    ...options,
  });
};

// Import/Export Hooks
export const useImportFAQs = (
  options?: UseMutationOptions<ApiResponse<{
    imported: number;
    updated: number;
    errors: Array<{ row: number; error: string }>;
    preview?: FAQ[];
  }>, Error, { file: File; options?: {
    categoryId?: string;
    skipErrors?: boolean;
    updateExisting?: boolean;
    dryRun?: boolean;
  } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ file, options }) => faqApi.importFAQs(file, options),
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faq-stats'] });
    },
    ...options,
  });
};

export const useExportFAQs = (
  options?: UseMutationOptions<ApiResponse<{ downloadUrl: string; filename: string }>, Error, {
    format?: 'csv' | 'xlsx' | 'json' | 'pdf';
    category?: string;
    status?: FAQ['status'];
    includeAnalytics?: boolean;
    includeTranslations?: boolean;
  }>
) => {
  return useMutation({
    mutationFn: faqApi.exportFAQs,
    ...options,
  });
};

// AI & Automation Hooks
export const useGenerateFAQFromContent = (
  options?: UseMutationOptions<ApiResponse<Array<{
    question: string;
    answer: string;
    confidence: number;
    suggestedTags: string[];
  }>>, Error, {
    content: string;
    contentType: 'article' | 'documentation' | 'conversation' | 'support_ticket';
    categoryId?: string;
    maxFAQs?: number;
  }>
) => {
  return useMutation({
    mutationFn: faqApi.generateFAQFromContent,
    ...options,
  });
};

export const useImproveFAQAnswer = (
  options?: UseMutationOptions<ApiResponse<{
    improvedAnswer: string;
    suggestions: string[];
    changes: Array<{ type: string; description: string }>;
  }>, Error, { id: string; options?: {
    tone?: 'professional' | 'friendly' | 'technical' | 'casual';
    length?: 'shorter' | 'longer' | 'detailed';
    includeExamples?: boolean;
  } }>
) => {
  return useMutation({
    mutationFn: ({ id, options }) => faqApi.improveFAQAnswer(id, options),
    ...options,
  });
};

export const useSimilarFAQs = (
  id: string,
  threshold?: number,
  options?: UseQueryOptions<ApiResponse<Array<{
    faq: FAQ;
    similarity: number;
    commonKeywords: string[];
  }>>>
) => {
  return useQuery({
    queryKey: ['similar-faqs', id, threshold],
    queryFn: () => faqApi.getSimilarFAQs(id, threshold),
    enabled: !!id,
    ...options,
  });
};

export const useTranslateFAQ = (
  options?: UseMutationOptions<ApiResponse<{
    translations: Array<{
      language: string;
      question: string;
      answer: string;
      confidence: number;
    }>;
  }>, Error, { id: string; targetLanguages: string[] }>
) => {
  return useMutation({
    mutationFn: ({ id, targetLanguages }) => faqApi.translateFAQ(id, targetLanguages),
    ...options,
  });
};

// Translation Hooks
export const useFAQTranslations = (
  id: string,
  options?: UseQueryOptions<ApiResponse<Array<{
    language: string;
    question: string;
    answer: string;
    metaTitle?: string;
    metaDescription?: string;
    status: 'active' | 'needs_review' | 'outdated';
  }>>>
) => {
  return useQuery({
    queryKey: ['faq-translations', id],
    queryFn: () => faqApi.getFAQTranslations(id),
    enabled: !!id,
    ...options,
  });
};

export const useUpdateFAQTranslation = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { id: string; language: string; data: {
    question: string;
    answer: string;
    metaTitle?: string;
    metaDescription?: string;
  } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, language, data }) => faqApi.updateFAQTranslation(id, language, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-translations', id] });
    },
    ...options,
  });
};

export const useDeleteFAQTranslation = (
  options?: UseMutationOptions<ApiResponse<void>, Error, { id: string; language: string }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, language }) => faqApi.deleteFAQTranslation(id, language),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faq-translations', id] });
    },
    ...options,
  });
};

// Review & Moderation Hooks
export const useFAQsForReview = (
  params?: PaginationParams,
  options?: UseQueryOptions<ApiResponse<FAQ[]>>
) => {
  return useQuery({
    queryKey: ['faqs-for-review', params],
    queryFn: () => faqApi.getFAQsForReview(params),
    ...options,
  });
};

export const useReviewFAQ = (
  options?: UseMutationOptions<ApiResponse<FAQ>, Error, { id: string; data: {
    approved: boolean;
    notes?: string;
    changes?: Partial<UpdateFAQRequest>;
  } }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, data }) => faqApi.reviewFAQ(id, data),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs'] });
      queryClient.invalidateQueries({ queryKey: ['faqs-for-review'] });
    },
    ...options,
  });
};

export const useFlagFAQForReview = (
  options?: UseMutationOptions<ApiResponse<{ flagged: boolean }>, Error, { id: string; reason?: string }>
) => {
  const queryClient = useQueryClient();
  
  return useMutation({
    mutationFn: ({ id, reason }) => faqApi.flagFAQForReview(id, reason),
    onSuccess: (data, { id }) => {
      queryClient.invalidateQueries({ queryKey: ['faq', id] });
      queryClient.invalidateQueries({ queryKey: ['faqs-for-review'] });
    },
    ...options,
  });
};

// Validation Hooks
export const useValidateFAQ = (
  options?: UseMutationOptions<ApiResponse<{
    valid: boolean;
    errors: Array<{ field: string; message: string }>;
    warnings: Array<{ field: string; message: string }>;
    suggestions: string[];
    seoScore: number;
    readabilityScore: number;
  }>, Error, CreateFAQRequest>
) => {
  return useMutation({
    mutationFn: faqApi.validateFAQ,
    ...options,
  });
};

export const useCheckDuplicates = (
  options?: UseMutationOptions<ApiResponse<Array<{
    faq: FAQ;
    similarity: number;
    matchType: 'exact' | 'similar' | 'partial';
  }>>, Error, { question: string; categoryId?: string }>
) => {
  return useMutation({
    mutationFn: ({ question, categoryId }) => faqApi.checkDuplicates(question, categoryId),
    ...options,
  });
};

export default faqApi;
